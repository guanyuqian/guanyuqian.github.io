(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{768:function(t,v,_){"use strict";_.r(v);var a=_(3),l=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"title"}),_("p",[t._v("在此处对MQ的概念进行介绍，以及对比主流几款MQ。")])]),t._v(" "),_("h2",{attrs:{id:"为什么使用mq"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么使用mq"}},[t._v("#")]),t._v(" 为什么使用MQ")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("解耦")]),t._v("：将各个模块进行解耦，提高对整体系统的维护效率。")]),t._v(" "),_("li",[_("strong",[t._v("异步")]),t._v("：对于实时性要求不高的业务，使用消息队列实现异步，可以提升核心功能的相应时间，提供核心流程成功率。")]),t._v(" "),_("li",[_("strong",[t._v("削峰")]),t._v("：也就是限流，防止在极端场景下的高并发把服务器打卦。")])]),t._v(" "),_("p",[t._v("MQ 可以应用但不局限于以下业务场景：")]),t._v(" "),_("ul",[_("li",[t._v("一对多，多对多异步解耦，基于发布订阅模型，对分布式应用进行异步解耦，增加应用的水平扩展能力。")]),t._v(" "),_("li",[t._v("削峰填谷，大促等流量洪流突然来袭时，MQ 可以缓冲突发流量，避免下游订阅系统因突发流量崩溃。")]),t._v(" "),_("li",[t._v("日志监控，作为重要日志的监控通信管道，将应用日志监控对系统性能影响降到最低。")]),t._v(" "),_("li",[t._v("消息推送，为社交应用和物联网应用提供点对点推送，一对多广播式推送的能力。")]),t._v(" "),_("li",[t._v("金融报文，发送金融报文，实现金融准实时的报文传输，可靠安全。")]),t._v(" "),_("li",[t._v("电信信令，将电信信令封装成消息，传递到各个控制终端，实现准实时控制和信息传递。")])]),t._v(" "),_("h2",{attrs:{id:"mq概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mq概念"}},[t._v("#")]),t._v(" MQ概念")]),t._v(" "),_("p",[t._v("衡量MQ，可以从多种特性维度去衡量，不同的产品在各种特性上有自己的选择，没有绝对好的实现，要结合使用场景来考虑适合使用那种类型的MQ。")]),t._v(" "),_("h3",{attrs:{id:"性能"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#性能"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),_("ul",[_("li",[t._v("单实现（集群or机器）吞吐量几万")]),t._v(" "),_("li",[t._v("十几万")]),t._v(" "),_("li",[t._v("几十万")]),t._v(" "),_("li",[t._v("上百万")])]),t._v(" "),_("h3",{attrs:{id:"顺序保证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#顺序保证"}},[t._v("#")]),t._v(" 顺序保证")]),t._v(" "),_("ul",[_("li",[t._v("无序：为了保证传输性能，无序消息不保证所有消息的传输先后顺序。")]),t._v(" "),_("li",[t._v("partition有序：保证一部分消息的先后顺序。")]),t._v(" "),_("li",[t._v("整体有序：保证全局消息的先后顺序。")])]),t._v(" "),_("h3",{attrs:{id:"交付保证-消息重复"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#交付保证-消息重复"}},[t._v("#")]),t._v(" 交付保证（消息重复）")]),t._v(" "),_("p",[t._v("这里也仅仅只是一般级别的交付保证，不能保证在极端情况下这些系统还支持，这需要形式化验证来证明。")]),t._v(" "),_("ul",[_("li",[t._v("At most once：订阅者最多收到1条同样的消息，可能存在消息丢失情况，开销最小。")]),t._v(" "),_("li",[t._v("At least once：订阅者最少收到1条同样的消息，可能存在消息重复情况，开销一般。")]),t._v(" "),_("li",[t._v("Exactly once：订阅者正好收到1条同样的消息，理想情况，开销最大。")])]),t._v(" "),_("h3",{attrs:{id:"消费模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消费模式"}},[t._v("#")]),t._v(" 消费模式")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("推模型：生产者需要把消息进行推送，当生产大于消费的时候，可能会出现消费者被打挂的情况。")])]),t._v(" "),_("li",[_("p",[t._v("拉模型：消费者在消费消息的时候再拉取，当消费大于生产的时候，可能会出现空转情况。")])])]),t._v(" "),_("h3",{attrs:{id:"消息轨迹路由查询"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息轨迹路由查询"}},[t._v("#")]),t._v(" 消息轨迹路由查询")]),t._v(" "),_("p",[t._v("是否支持MQ消息发送过程中的全链路查询，如果消息发送失败知道在那个环境出现了问题。")]),t._v(" "),_("h3",{attrs:{id:"容灾"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#容灾"}},[t._v("#")]),t._v(" 容灾")]),t._v(" "),_("p",[t._v("容灾备份一定程度上和MQ的存储实现与集群支持有关，支持磁盘存储+集群备份就更自然的实现对灾备的支持。此外就是是否独立设计了系统进行异常情况的自动运维功能。")]),t._v(" "),_("ul",[_("li",[t._v("容灾备份")]),t._v(" "),_("li",[t._v("人工立即介入恢复")]),t._v(" "),_("li",[t._v("一定程度上自动恢复（检测、替换、重启）")])]),t._v(" "),_("h3",{attrs:{id:"延迟消息"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#延迟消息"}},[t._v("#")]),t._v(" 延迟消息")]),t._v(" "),_("p",[t._v("能否支持延迟发送或者延迟消费的消息模式")]),t._v(" "),_("h3",{attrs:{id:"持久化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[t._v("#")]),t._v(" 持久化")]),t._v(" "),_("p",[t._v("持久化位置可以分为")]),t._v(" "),_("ul",[_("li",[t._v("只存在生产端")]),t._v(" "),_("li",[t._v("只存在消费端")]),t._v(" "),_("li",[t._v("同时存在生产端和消费端")]),t._v(" "),_("li",[t._v("部分存在生产端和消费端")])]),t._v(" "),_("p",[t._v("持久化形式可以分为：")]),t._v(" "),_("ul",[_("li",[t._v("磁盘")]),t._v(" "),_("li",[t._v("内存")]),t._v(" "),_("li",[t._v("数据库")])]),t._v(" "),_("h3",{attrs:{id:"事务-最终一致性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#事务-最终一致性"}},[t._v("#")]),t._v(" 事务（最终一致性）")]),t._v(" "),_("p",[t._v("解决数据库的事务和MQ消息的数据一致性，即数据库系统添加失败后支不支持MQ级别的事务同步回滚")]),t._v(" "),_("h3",{attrs:{id:"消息回溯"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息回溯"}},[t._v("#")]),t._v(" 消息回溯")]),t._v(" "),_("p",[t._v("在某个时间点之后一系列消息被消费完了，能否支持重新回到这个时间点重新消费已经消费过的消息。这一定程度上取决于MQ的存储方式实现，如果只在内存中存储，就不可能支持长时间的消息回溯，如果结合了磁盘存储就有可能实现长时间的消息回溯。")]),t._v(" "),_("ul",[_("li",[t._v("不支持")]),t._v(" "),_("li",[t._v("在一个partition内实现")]),t._v(" "),_("li",[t._v("全局实现")])]),t._v(" "),_("h3",{attrs:{id:"集群支持"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#集群支持"}},[t._v("#")]),t._v(" 集群支持")]),t._v(" "),_("ul",[_("li",[t._v("单机")]),t._v(" "),_("li",[t._v("集群一主多从")]),t._v(" "),_("li",[t._v("集群多主多从")])]),t._v(" "),_("h3",{attrs:{id:"死信处理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死信处理"}},[t._v("#")]),t._v(" 死信处理")]),t._v(" "),_("p",[t._v("对没有被正常消费的消息，会怎样处理")]),t._v(" "),_("ul",[_("li",[t._v("直接丢弃")]),t._v(" "),_("li",[t._v("重试多次")]),t._v(" "),_("li",[t._v("放入死信队列，等待后续定义处理")])]),t._v(" "),_("h2",{attrs:{id:"mq对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mq对比"}},[t._v("#")]),t._v(" MQ对比")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th"),t._v(" "),_("th",[t._v("ActiveMQ")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("RabbitMQ")]),t._v(" "),_("th",[t._v("RocketMq")]),t._v(" "),_("th",[t._v("Kafka")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("持久化")]),t._v(" "),_("td",[t._v("内存、磁盘、数据库。支持少量堆积。")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("内存、磁盘。支持少量堆积")]),t._v(" "),_("td",[t._v("磁盘。支持大量堆积。")]),t._v(" "),_("td",[t._v("内存、磁盘、数据库。支持大量堆积")])]),t._v(" "),_("tr",[_("td",[t._v("事务")]),t._v(" "),_("td",[t._v("支持")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("特殊支持，性能损失严重")]),t._v(" "),_("td",[t._v("支持")]),t._v(" "),_("td",[t._v("支持")])]),t._v(" "),_("tr",[_("td",[t._v("单机吞吐量")]),t._v(" "),_("td",[t._v("几万")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("几万")]),t._v(" "),_("td",[t._v("十万")]),t._v(" "),_("td",[t._v("几十万")])]),t._v(" "),_("tr",[_("td",[t._v("消费模式")]),t._v(" "),_("td",[t._v("push/pull")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("push/ pull")]),t._v(" "),_("td"),t._v(" "),_("td",[t._v("pull")])]),t._v(" "),_("tr",[_("td",[t._v("集群支持")]),t._v(" "),_("td",[t._v("一主多从")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("一主多从")]),t._v(" "),_("td",[t._v("多主多从")]),t._v(" "),_("td",[t._v("多主（分布式）")])]),t._v(" "),_("tr",[_("td",[t._v("消息顺序")]),t._v(" "),_("td",[t._v("无序")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("无序")]),t._v(" "),_("td",[t._v("无序、partition有序、全局有序")]),t._v(" "),_("td",[t._v("partition有序")])]),t._v(" "),_("tr",[_("td",[t._v("消息回溯")]),t._v(" "),_("td",[t._v("不支持")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("不支持")]),t._v(" "),_("td",[t._v("支持指定时间点的回溯")]),t._v(" "),_("td",[t._v("支持指定分区offset位置的回溯")])]),t._v(" "),_("tr",[_("td",[t._v("负载均衡")]),t._v(" "),_("td",[t._v("支持友好")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("支持不好")]),t._v(" "),_("td",[t._v("支持友好")]),t._v(" "),_("td",[t._v("支持友好")])]),t._v(" "),_("tr",[_("td",[t._v("交付保证")]),t._v(" "),_("td",[t._v("at least once")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("at least once、at most once")]),t._v(" "),_("td",[t._v("at least once")]),t._v(" "),_("td",[t._v("at least once、at most once")])]),t._v(" "),_("tr",[_("td",[t._v("死信处理")]),t._v(" "),_("td",[t._v("不支持，可以自己实现")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("不支持，可以自己实现")]),t._v(" "),_("td",[t._v("定时重发、死信队列")]),t._v(" "),_("td",[t._v("不支持，可以自己实现")])]),t._v(" "),_("tr",[_("td",[t._v("评价")]),t._v(" "),_("td",[t._v("成熟的产品，在很多公司得到应用，各种协议支持的都很好。")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("结合erlang语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护。不过，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug。")]),t._v(" "),_("td",[t._v("天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。")]),t._v(" "),_("td",[t._v("号称大数据的杀手锏，谈到大数据领域内的消息传输，Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。")])]),t._v(" "),_("tr",[_("td",[t._v("应用场景")]),t._v(" "),_("td",[t._v("官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("如果你的数据量没有那么大，小公司优先选择功能比较完备的RabbitMQ。")]),t._v(" "),_("td",[t._v("RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ。")]),t._v(" "),_("td",[t._v("大型公司建议可以选用，如果有日志采集功能，肯定是首选kafka了。")])])])])])}),[],!1,null,null,null);v.default=l.exports}}]);