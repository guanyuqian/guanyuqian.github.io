(window.webpackJsonp=window.webpackJsonp||[]).push([[134],{733:function(e,r,s){"use strict";s.r(r);var n=s(3),a=Object(n.a)({},(function(){var e=this,r=e.$createElement,s=e._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"title"}),s("p",[e._v("本译文摘自Dave Cheney于2016年在日本东京举行的"),s("a",{attrs:{href:"https://link.juejin.cn/?target=http%3A%2F%2Fgocon.connpass.com%2Fevent%2F27521%2F",target:"_blank",rel:"noopener noreferrer"}},[e._v("GoCon春季"),s("OutboundLink")],1),e._v("会议上的演讲。")])]),e._v(" "),s("blockquote",[s("p",[e._v("https://www.youtube.com/watch?v=lsBF58Q-DnY")]),e._v(" "),s("p",[e._v("https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully")])]),e._v(" "),s("h2",{attrs:{id:"关于-dave-cheney"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于-dave-cheney"}},[e._v("#")]),e._v(" 关于 Dave Cheney")]),e._v(" "),s("p",[s("a",{attrs:{href:"https://dave.cheney.net/about",target:"_blank",rel:"noopener noreferrer"}},[e._v("Dave Cheney"),s("OutboundLink")],1),e._v("是Go编程语言的开源贡献者和项目成员。Dave Cheney是科技界备受尊重的代言人，他讲的是软件设计，性能和Go编程语言等各种主题。从2009年起，Dave Cheney就开始在世界各地写作，教学和演讲golang。Dave Cheney目前是VMware技术人员。在他的前公司收购之前，他曾在位于西雅图的公司Heptio担任工程师，专注于构建工具，帮助开发人员提高Kubernetes的工作效率。")]),e._v(" "),s("h2",{attrs:{id:"errors-are-just-values"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#errors-are-just-values"}},[e._v("#")]),e._v(" Errors are just values")]),e._v(" "),s("p",[e._v("我花了很多时间考虑Go程序中错误处理的最佳方法。我真希望存在单一的错误处理方式，可以通过死记硬背教给所有Go程序员，就像教数学或英文字母表一样。")]),e._v(" "),s("p",[e._v("但是，我得出结论，不存在单一的错误处理方式。 相反，我认为Go的错误处理可以分为三个核心策略。")]),e._v(" "),s("h2",{attrs:{id:"sentinel-errors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sentinel-errors"}},[e._v("#")]),e._v(" Sentinel errors")]),e._v(" "),s("p",[e._v("第一类错误处理就是我所说的_sentinel errors_。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("if err == ErrSomething { … }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("该名称源于计算机编程中使用特定值的实践，表示不可能进一步处理。 因此，对于Go，我们使用特定值来表示错误。")]),e._v(" "),s("p",[e._v("例子包括 "),s("code",[e._v("io.EOF")]),e._v(" 类的值，或低层级的错误，如 "),s("code",[e._v("syscall")]),e._v(" 包中的常 "),s("code",[e._v("syscall.ENOENT")]),e._v("。甚至还有 "),s("code",[e._v("sentinel errors")]),e._v(" 表示_没有_发生错误，比如 "),s("code",[e._v("go/build.NoGoError")]),e._v(" , 和 "),s("code",[e._v("path/filepath.Walk")]),e._v(" 的 "),s("code",[e._v("path/filepath.SkipDir")]),e._v("。")]),e._v(" "),s("p",[e._v("使用 "),s("code",[e._v("sentinel")]),e._v(" 值是灵活性最小的错误处理策略，因为调用者必须使用等于运算符，将结果与预先声明的值进行比较（如下代码）。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('buf := make([]byte, 100)\nn, err := r.Read(buf)\nbuf = buf[:n]\nif err == io.EOF {\n  log.Fatal("read failed:", err)\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("p",[e._v("**（错误实践）**当您想要提供更多上下文时就会出现问题，因为返回一个不同的错误会破坏相等检查。即使是用心良苦的使用 "),s("code",[e._v("fmt.Errorf")]),e._v(" 为错误添加一些上下文，将使调用者的相等测试失败。 调用者转而被迫查看  "),s("code",[e._v("error")]),e._v("的 "),s("code",[e._v("Error")]),e._v(" 方法的输出，以查看它是否与特定字符串匹配。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('func readfile(path string) error {\n  err := openfile(path)\n  if err != nil {\n    return fmt.Errorf("cannot open file: %v", err)\n  }\n  ...\n}\n\nfunc main() {\n  err := readfile(".bashrc")\n  if strings.Contains(error.Error(),"not found") {\n    // handle error\n  }\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br"),s("span",{staticClass:"line-number"},[e._v("14")]),s("br")])]),s("h3",{attrs:{id:"never-inspect-the-output-of-error-error"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#never-inspect-the-output-of-error-error"}},[e._v("#")]),e._v(" Never inspect the output of error.Error")]),e._v(" "),s("p",[e._v("我认为永远不应该检查 "),s("code",[e._v("error.Error")]),e._v(" 方法的输出。"),s("code",[e._v("error")]),e._v(" 接口上的 "),s("code",[e._v("Error")]),e._v(" 方法是为人类理解上下文，而不是为代码判断错误而存在的。")]),e._v(" "),s("p",[s("code",[e._v("Error")]),e._v("方法打印的字符串的内容属于日志文件，或显示在屏幕上。 您不应该尝试通过检查它以更改程序的行为。")]),e._v(" "),s("p",[e._v("我知道有时候这是不可能的，正如有人在推特上指出的那样，此建议并不适用于编写测试。 更重要的是，在我看来，"),s("strong",[e._v("比较错误的字符串形式是一种代码气味，你应该尽量避免它。")])]),e._v(" "),s("h3",{attrs:{id:"sentinel-errors-become-part-of-your-public-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sentinel-errors-become-part-of-your-public-api"}},[e._v("#")]),e._v(" Sentinel errors become part of your public API")]),e._v(" "),s("p",[e._v("如果您的 public 函数或方法返回特定值的错误，那么该值必须是 public 的，当然还要有文档记录。 这会增加API的面积。")]),e._v(" "),s("p",[e._v("如果您的API定义了一个返回特定错误的接口，则该接口的所有实现都将被限制为仅返回该错误，即使它们可能提供更具描述性的错误。")]),e._v(" "),s("p",[e._v("通过 "),s("code",[e._v("io.Reader")]),e._v(" 看到这一点 。 像 "),s("code",[e._v("io.Copy")]),e._v(" 这样的函数，需要一个 "),s("code",[e._v("reader")]),e._v(" 实现来_精确_地返回 "),s("code",[e._v("io.EOF")]),e._v("，以便向调用者发出不再有数据的信号，但这不是错误 。")]),e._v(" "),s("h3",{attrs:{id:"sentinel-errors-create-a-dependency-between-two-packages"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sentinel-errors-create-a-dependency-between-two-packages"}},[e._v("#")]),e._v(" Sentinel errors create a dependency between two packages")]),e._v(" "),s("p",[e._v("到目前为止，"),s("code",[e._v("sentinel error values")]),e._v(" 的最大问题是它们在两个包之间创建源代码依赖性。 例如，要检查错误是否等于 "),s("code",[e._v("io.EOF")]),e._v("，您的代码必 import "),s("code",[e._v("io")]),e._v(" 包。")]),e._v(" "),s("p",[e._v("这个具体示例听起来并不那么糟糕，因为它很常见，但想象一下，当项目中的许多包导出 "),s("code",[e._v("error values")]),e._v("，项目中的其他包必须 import 以检查特定的错误条件时存在的耦合。")]),e._v(" "),s("p",[e._v("在一个玩弄这种模式的大型项目中工作过，我可以告诉你，以 import 循环的形式出现的糟糕设计的幽灵从未远离我们的脑海。")]),e._v(" "),s("h3",{attrs:{id:"conclusion-avoid-sentinel-errors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#conclusion-avoid-sentinel-errors"}},[e._v("#")]),e._v(" Conclusion: avoid sentinel errors")]),e._v(" "),s("p",[e._v("所以，我的建议是在你编写的代码中避免使用 "),s("code",[e._v("sentinel error values")]),e._v("。 在某些情况下，它们会在标准库中使用，但你不应该模仿这种模式。")]),e._v(" "),s("p",[e._v("如果有人要求您从包中导出错误值，您应该礼貌地拒绝，而是建议一种替代方法，例如我将在下面讨论的方法。")]),e._v(" "),s("h2",{attrs:{id:"error-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#error-types"}},[e._v("#")]),e._v(" Error types")]),e._v(" "),s("p",[s("code",[e._v("Error types")]),e._v(" 是我想讨论的Go错误处理的第二种形式。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("if err, ok := err.(SomeType); ok { … }\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("错误类型是您创建的实现错误接口的类型。 在此示例中，"),s("code",[e._v("MyError")]),e._v(" 类型跟踪文件和行，以及解释所发生情况的消息。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('type MyError struct {\n\tMsg string\n\tFile string\n\tLine int\n}\n\nfunc (e *MyError) Error() string {\n\treturn fmt.Sprintf("%s:%d: %s”, e.File, e.Line, e.Msg)\n}\n\nreturn &MyError{"Something happened", “server.go", 42}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[e._v("由于 "),s("code",[e._v("MyError error")]),e._v(" 是一种类型，因此调用者可以使用类型断言从错误中提取额外的上下文。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("err := something()\nswitch err := err.(type) {\ncase nil:\n// call succeeded, nothing to do\ncase *MyError:\nfmt.Println(“error occurred on line:”, err.Line)\ndefault:\n// unknown error\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[s("code",[e._v("error types")]),e._v(" 相对于 "),s("code",[e._v("error values")]),e._v(" 的重大改进是，它们能够包装底层错误以提供更多上下文。")]),e._v(" "),s("p",[e._v("一个很好的例子是 "),s("code",[e._v("os.PathError")]),e._v(" 类型，它通过它试图执行的操作和它试图使用的文件来注释底层错误。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// PathError records an error and the operation\n// and file path that caused it.\ntype PathError struct {\n\tOp string\n\tPath string\n\tErr error // the cause\n}\n\nfunc (e *PathError) Error() string\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("h3",{attrs:{id:"problems-with-error-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#problems-with-error-types"}},[e._v("#")]),e._v(" Problems with error types")]),e._v(" "),s("p",[e._v("调用者可以使用类型断言或类型 switch，"),s("code",[e._v("error types")]),e._v(" 必须是 public。")]),e._v(" "),s("p",[e._v("如果您的代码实现了一个接口，其契约需要特定的错误类型，则该接口的所有实现者都需要依赖于定义错误类型的包。")]),e._v(" "),s("p",[e._v("对包类型的深入了解，会建立与调用者很强耦合，从而形成一个脆弱的API。")]),e._v(" "),s("h3",{attrs:{id:"conclusion-avoid-error-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#conclusion-avoid-error-types"}},[e._v("#")]),e._v(" Conclusion: avoid error types")]),e._v(" "),s("p",[e._v("虽然 "),s("code",[e._v("error types")]),e._v(" 比 "),s("code",[e._v("sentinel error values")]),e._v(" 更好，因为它们可以捕获更多关于错误的上下文，错误类型同样拥有许多 "),s("code",[e._v("error values")]),e._v(" 的问题。")]),e._v(" "),s("p",[e._v("所以我的建议是避免 "),s("code",[e._v("error types")]),e._v("，或者至少避免使它们成为公共API的一部分。")]),e._v(" "),s("h2",{attrs:{id:"opaque-errors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#opaque-errors"}},[e._v("#")]),e._v(" Opaque errors")]),e._v(" "),s("p",[e._v("现在我们来看第三类错误处理。 在我看来，这是最灵活的错误处理策略，因为它需要的代码和调用者之间的耦合最小。")]),e._v(" "),s("p",[e._v("我将这种方式称为不透明的错误处理，因为虽然您知道发生了错误，但您无法查看错误内部。 作为调用者，您对操作结果的所有了解都是有效的，或者没有。")]),e._v(" "),s("p",[e._v("这就是不透明的错误处理 - 只返回错误而不假设其内容。 如果采用此方式，则错误处理可以作为调试辅助工具，变得非常有用。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import “github.com/quux/bar”\n\nfunc fn() error {\n\tx, err := bar.Foo()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// use x\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("例如，"),s("code",[e._v("Foo")]),e._v(" 的契约不保证它将在错误的上下文中返回什么。通过传递错误附带额外的上下文，"),s("code",[e._v("Foo")]),e._v(" 的作者现在可以自由地注释错误，而不会违反与调用者的契约。")]),e._v(" "),s("h3",{attrs:{id:"assert-errors-for-behaviour-not-type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#assert-errors-for-behaviour-not-type"}},[e._v("#")]),e._v(" Assert errors for behaviour, not type")]),e._v(" "),s("p",[e._v("在少数情况下，使用二分法（是否有错误）来进行错误处理是不够的。")]),e._v(" "),s("p",[e._v("例如，与进程外部的服务（例如网络活动）的交互，要求调用者查看错误的性质，以确定重试操作是否合理。")]),e._v(" "),s("p",[e._v("在这种情况下，我们可以断言错误实现了特定的行为，而不是断言错误是特定的类型或值。 考虑这个例子：")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type temporary interface {\n\tTemporary() bool\n}\n\n// IsTemporary returns true if err is temporary.\nfunc IsTemporary(err error) bool {\n\tte, ok := err.(temporary)\n\treturn ok && te.Temporary()\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br")])]),s("p",[e._v("可以将任何错误传递给 "),s("code",[e._v("IsTemporary")]),e._v(" 以确定错误是否可以重试。")]),e._v(" "),s("p",[e._v("如果错误没有实现 "),s("code",[e._v("temporary")]),e._v(" 接口; 也就是说，它没有 "),s("code",[e._v("Temporary")]),e._v(" 方法，那么错误不是临时的。")]),e._v(" "),s("p",[e._v("如果错误确实实现了 "),s("code",[e._v("Temporary")]),e._v("，那么如果 "),s("code",[e._v("true")]),e._v(" 返回true ，调用者可以重试该操作。")]),e._v(" "),s("p",[e._v("这里的关键是，此逻辑可以在不导入定义错误的包，或者直接知道任何关于 "),s("code",[e._v("err")]),e._v("的基础类型的情况下实现 - 我们只是对它的行为感兴趣。")]),e._v(" "),s("h3",{attrs:{id:"don-t-just-check-errors-handle-them-gracefully"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#don-t-just-check-errors-handle-them-gracefully"}},[e._v("#")]),e._v(" Don’t just check errors, handle them gracefully")]),e._v(" "),s("p",[e._v("让我想到了第二句Go谚语，我想谈谈; 不要仅仅检查错误，优雅地处理它们。 你能用以下代码提出一些问题吗？")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("func AuthenticateRequest(r *Request) error {\n\terr := authenticate(r.User)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("一个明显的建议是，函数的五行可以替换为:")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("return authenticate(r.User)\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("但这是每个人都应该在代码审查中发现的简单问题。这段代码更根本的问题是无法分辨原始错误来自哪里。")]),e._v(" "),s("p",[e._v("如果 "),s("code",[e._v("authenticate")]),e._v(" 返回错误，那么 "),s("code",[e._v("AuthenticateRequest")]),e._v(" 会将错误返回给调用者，调用者也可能会这样做，依此类推。 在程序的顶部，程序的主体将错误打印到屏幕或日志文件，所有打印的都会是： "),s("code",[e._v("No such file or directory")]),e._v(" 。")]),e._v(" "),s("p",[e._v("没有生成错误的文件和行的信息。 没有导致错误的调用堆栈的 "),s("code",[e._v("stack trace")]),e._v("。 该代码的作者将被迫进行一个长的会话，将他们的代码二等分，以发现哪个代码路径触发了文件未找到错误。")]),e._v(" "),s("p",[e._v("Donovan和Kernighan的_The Go Programming Language_建议您使用 "),s("code",[e._v("fmt.Errorf")]),e._v(" 向错误路径添加上下文")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('func AuthenticateRequest(r *Request) error {\n\terr := authenticate(r.User)\n\tif err != nil {\n\t\treturn fmt.Errorf("authenticate failed: %v", err) // 新的错误类型，传递更多上下文\n\t}\n\treturn nil\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("但是正如我们之前看到的，这种模式与使用 "),s("code",[e._v("sentinel error values")]),e._v(" 或类型断言不兼容，因为将错误值转换为字符串，将其与另一个字符串合并，然后使用 "),s("code",[e._v("fmt.Errorf")]),e._v(" 将其转换回错误,破坏了相等性，同时完全破坏了原始错误中的上下文。")]),e._v(" "),s("h3",{attrs:{id:"annotating-errors"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#annotating-errors"}},[e._v("#")]),e._v(" Annotating errors")]),e._v(" "),s("p",[e._v("传统的错误生成方式如下：")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('err := errors.New("kerboom")\nfmt.Printf("%v\\n", err) // 打印出"kerboom"字符串\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("我想建议一种方法来为错误添加上下文，为此，我将介绍一个简单的包。 该代码在 "),s("a",{attrs:{href:"https://link.juejin.cn?target=https%3A%2F%2Fgodoc.org%2Fgithub.com%2Fpkg%2Ferrors",target:"_blank",rel:"noopener noreferrer"}},[s("code",[e._v("github.com/pkg/errors")]),s("OutboundLink")],1),e._v(" 提供。 错误包有两个主要函数：")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// Wrap annotates cause with a message.\nfunc Wrap(cause error, message string) error\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("第一个函数是 "),s("code",[e._v("Wrap")]),e._v("，它接收一个错误和一段消息，并产生一个新的错误。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// Cause unwraps an annotated error.\nfunc Cause(err error) error\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br")])]),s("p",[e._v("第二个函数是 "),s("code",[e._v("Cause")]),e._v("，它接收可能已被包装的错误，并将其解包以恢复原始错误。")]),e._v(" "),s("p",[e._v("使用这两个函数，我们现在可以注释任何错误，并在需要检查时恢复底层错误。 考虑一个将文件内容读入内存的函数的例子。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('func ReadFile(path string) ([]byte, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, "open failed")\n\t}\n\tdefer f.Close()\n\n\tbuf, err := ioutil.ReadAll(f)\n\tif err != nil {\n\t\treturn nil, errors.Wrap(err, "read failed")\n\t}\n\treturn buf, nil\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[e._v("我们将使用此函数编写一个函数来读取配置文件，然后从 "),s("code",[e._v("main")]),e._v(" 调用它。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('func ReadConfig() ([]byte, error) {\n\thome := os.Getenv("HOME")\n\tconfig, err := ReadFile(filepath.Join(home, ".settings.xml"))\n\treturn config, errors.Wrap(err, "could not read config")\n}\n\nfunc main() {\n\t_, err := ReadConfig()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br"),s("span",{staticClass:"line-number"},[e._v("12")]),s("br"),s("span",{staticClass:"line-number"},[e._v("13")]),s("br")])]),s("p",[e._v("如果 "),s("code",[e._v("ReadConfig")]),e._v(" 代码路径失败，因为我们使用了 "),s("code",[e._v("errors.Wrap")]),e._v("，我们在K＆D样式中得到一个很好的注释错误。")]),e._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("could not "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("read")]),e._v(" config: "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("open")]),e._v(" failed: "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("open")]),e._v(" /Users/dfc/.settings.xml: no such "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("file")]),e._v(" or directory\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br")])]),s("p",[e._v("因为 "),s("code",[e._v("errors.Wrap")]),e._v(" 会产生堆栈错误，所以我们可以检查该堆栈以获取其他调试信息。 这又是一个相同的例子，但这次我们用 "),s("code",[e._v("fmt.Println")]),e._v(" 替换 "),s("code",[e._v("errors.Print")])]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("func main() {\n\t_, err := ReadConfig()\n\tif err != nil {\n\t\terrors.Print(err)\n\t\tos.Exit(1)\n\t}\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("我们会得到如下信息：")]),e._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[e._v("readfile.go:27: could not "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("read")]),e._v(" config\nreadfile.go:14: "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("open")]),e._v(" failed\n"),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("open")]),e._v(" /Users/dfc/.settings.xml: no such "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("file")]),e._v(" or directory\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("第一行来自 "),s("code",[e._v("ReadConfig")]),e._v("，第二行来自 "),s("code",[e._v("ReadFile")]),e._v(" 的 "),s("code",[e._v("os.Open")]),e._v(" 部分，其余部分来自 "),s("code",[e._v("os")]),e._v(" 包本身，它不携带位置信息。")]),e._v(" "),s("p",[e._v("现在我们已经介绍了包装错误生成堆栈的概念，我们需要讨论反向操作，展开它们。 这是 "),s("code",[e._v("errors.Cause")]),e._v(" 函数的域。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// IsTemporary returns true if err is temporary.\nfunc IsTemporary(err error) bool {\n\tte, ok := errors.Cause(err).(temporary)\n\treturn ok && te.Temporary()\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br")])]),s("p",[e._v("在操作中，每当您需要检查错误是否与特定值或类型匹配时，您应首先使用 "),s("code",[e._v("errors.Cause")]),e._v(" 函数恢复原始错误。")]),e._v(" "),s("h3",{attrs:{id:"only-handle-errors-once"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#only-handle-errors-once"}},[e._v("#")]),e._v(" Only handle errors once")]),e._v(" "),s("p",[e._v("最后，我想提一下：你应该只处理一次错误。 处理错误意味着检查错误值并做出决定。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("func Write(w io.Writer, buf []byte) {\n\tw.Write(buf)\n}\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br")])]),s("p",[e._v("如果不做决定，则忽略该错误。 正如我们在这里看到的那样，"),s("code",[e._v("w.Write")]),e._v(" 的错误被丢弃了。")]),e._v(" "),s("p",[e._v("但是，针对单个错误做出多个决策也存在问题。")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('func Write(w io.Writer, buf []byte) error {\n\t_, err := w.Write(buf)\n\tif err != nil {\n\t\t// annotated error goes to log file\n\t\tlog.Println("unable to write:", err)\n\n\t\t// unannotated error returned to caller\n\t\treturn err\n\t}\n\treturn nil\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br"),s("span",{staticClass:"line-number"},[e._v("8")]),s("br"),s("span",{staticClass:"line-number"},[e._v("9")]),s("br"),s("span",{staticClass:"line-number"},[e._v("10")]),s("br"),s("span",{staticClass:"line-number"},[e._v("11")]),s("br")])]),s("p",[e._v("在此示例中，如果在 "),s("code",[e._v("Write")]),e._v(" 期间发生错误，则会将一行写入日志文件，注意错误发生的文件和行，并且错误也会返回给调用者，调用者可能会将其记录并返回，一路回到程序的顶部。")]),e._v(" "),s("p",[e._v("因此，您在日志文件中获得了重复的行的堆栈，但是在程序的顶部，您将获得没有原始错误的任何上下文。 有人使用Java吗？")]),e._v(" "),s("div",{staticClass:"language-golang line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('func Write(w io.Write, buf []byte) error {\n\t_, err := w.Write(buf)\n\treturn errors.Wrap(err, "write failed")\n}\n')])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br")])]),s("p",[e._v("使用 "),s("code",[e._v("errors")]),e._v(" 包，您可以以人和机器都可检查的方式向错误值添加上下文。")]),e._v(" "),s("h3",{attrs:{id:"conclusion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion")]),e._v(" "),s("p",[e._v("总之，错误是包 public API 的一部分，对待它们就像对待 public API 的其他部分一样小心。")]),e._v(" "),s("p",[e._v("为了获得最大的灵活性，我建议您尝试将所有错误都视为不透明的。在不能这样做的情况下，断言行为错误，而不是类型或值错误。")]),e._v(" "),s("p",[e._v("最小化程序中的 "),s("code",[e._v("sentinel error values")]),e._v("，并在错误发生时立即用 "),s("code",[e._v("errors.Wrap")]),e._v(" 将其包装，从而将错误转换为不透明错误。")]),e._v(" "),s("p",[e._v("最后，如果需要检查，请使用 "),s("code",[e._v("errors.Cause")]),e._v(" 恢复底层错误。")])])}),[],!1,null,null,null);r.default=a.exports}}]);