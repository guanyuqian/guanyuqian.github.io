(window.webpackJsonp=window.webpackJsonp||[]).push([[152],{778:function(v,_,t){"use strict";t.r(_);var s=t(3),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"title"}),t("p",[v._v("此处填写本题目的摘要")])]),v._v(" "),t("h2",{attrs:{id:"redis的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis的优点"}},[v._v("#")]),v._v(" Redis的优点")]),v._v(" "),t("ol",[t("li",[v._v("基于内存的：高性能")]),v._v(" "),t("li",[v._v("KV数据库：不使用RDS，因为应用场景是缓存，只存储部分数据，不需要实现数据关系支持")]),v._v(" "),t("li",[v._v("Worker单线程（IO多线程、flash、心跳线程）： 支持单个命令的原子操作，多个命令的部分事务（不支持回滚），使用Lua脚本可以实现多命令的原子性事务。")]),v._v(" "),t("li",[v._v("多种数据类型（每种类型都支持本地方法）：相较于Memcache把一部分缓存的逻辑处理交给Redis服务器执行，减少了大量不必要数据的网络IO消耗和caller服务器的缓解析性能。")])]),v._v(" "),t("h2",{attrs:{id:"redis的缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis的缺点"}},[v._v("#")]),v._v(" Redis的缺点")]),v._v(" "),t("ol",[t("li",[v._v("单线程的Worker无法充分利用多核CPU的性能，Redis6中使用IO多线程可以在一定程度上利用多核CPU的性能。")])]),v._v(" "),t("h2",{attrs:{id:"基本应用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本应用场景"}},[v._v("#")]),v._v(" "),t("a",{attrs:{href:"http://www.noobyard.com/article/p-wjpgpbmz-sg.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("基本应用场景"),t("OutboundLink")],1)]),v._v(" "),t("h3",{attrs:{id:"string类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string类型"}},[v._v("#")]),v._v(" string类型")]),v._v(" "),t("p",[v._v("string类型的数据也可以进行数值计算或者位运算操作，在底层存储的还是字符串。")]),v._v(" "),t("h4",{attrs:{id:"二进制安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二进制安全"}},[v._v("#")]),v._v(" 二进制安全")]),v._v(" "),t("p",[v._v("**二进制安全：**通俗的讲，C语言中，用“0”表示字符串的结束，如果字符串中本身就有“0”字符，那么这个字符串就会被截断，即非二进制安全；若通过某种机制，保证读写字符串时不损害其内容，则是二进制安全。")]),v._v(" "),t("p",[v._v("Redis有二进制安全的特点，即数据传输的时候会按照一定的格式进行编解码，不用关心具体的基本数据类型")]),v._v(" "),t("ol",[t("li",[v._v("session")]),v._v(" "),t("li",[v._v("KV缓存")]),v._v(" "),t("li",[v._v("数值计算器、计数器（原子性）")]),v._v(" "),t("li",[v._v("fs分布式文件系统（小文件）")]),v._v(" "),t("li",[v._v("分布式锁")]),v._v(" "),t("li",[v._v("JSON序列化数据存储所有类型的数据结构")])]),v._v(" "),t("h3",{attrs:{id:"bitmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bitmap"}},[v._v("#")]),v._v(" Bitmap")]),v._v(" "),t("p",[v._v("位图的最大长度为为2^32，redis中一个key限制不能大于512M，bit位个数尽量小于2^29-1(536870911)，大约5亿。如果UID过大可以使用分桶")]),v._v(" "),t("ol",[t("li",[v._v("统计一段时间窗口内用户的登录情况，利用bitmap进行登录窗口天数的维护")]),v._v(" "),t("li",[v._v("用户签到统计，以uid为偏移，位图作为用户的状态")]),v._v(" "),t("li",[v._v("布隆过滤器")])]),v._v(" "),t("h3",{attrs:{id:"list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[v._v("#")]),v._v(" List")]),v._v(" "),t("p",[v._v("特点是和放入数据的顺序有关")]),v._v(" "),t("ol",[t("li",[v._v("模拟本地数据结构，做到分布式服务器无状态，模拟简易的消息队列")]),v._v(" "),t("li",[v._v("朋友圈点赞列表、评论列表")]),v._v(" "),t("li",[v._v("弹幕")])]),v._v(" "),t("h3",{attrs:{id:"sorted-set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sorted-set"}},[v._v("#")]),v._v(" Sorted Set")]),v._v(" "),t("ol",[t("li",[v._v("投票排行榜、游戏排行榜")])]),v._v(" "),t("h3",{attrs:{id:"hashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[v._v("#")]),v._v(" HashMap")]),v._v(" "),t("p",[v._v("如果一段复杂的schema缓存每次需要取出全部field，可以使用JSON+String进行Redis存储，但是如果这个schema是经常有部分field取出的操作，可以使用HashMap进行存储。")]),v._v(" "),t("ol",[t("li",[v._v("复杂信息的schema，使用HashMap代替Json序列化复杂的数据结构")])]),v._v(" "),t("h3",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[v._v("#")]),v._v(" Set")]),v._v(" "),t("p",[v._v("Set的集合操作（Union、And、Or）比较复杂、消耗CPU、会让后续命令执行收到阻塞，所以慎用。")]),v._v(" "),t("ol",[t("li",[v._v("随机数：抽奖、验证码、扑克牌游戏等")]),v._v(" "),t("li",[v._v("首页商品的随机展示")]),v._v(" "),t("li",[v._v("社交网络中共同好友")])]),v._v(" "),t("h2",{attrs:{id:"redis持久化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化"}},[v._v("#")]),v._v(" Redis持久化")]),v._v(" "),t("p",[v._v("关键词：AOF、RDB、COW、FORK、AOF+RDB、CAP")]),v._v(" "),t("p",[v._v("Redis提供不同级别的持久化方案：")]),v._v(" "),t("ul",[t("li",[v._v("RDB（Redis Database）能够在指定时间间隔对数据进行快照存储")]),v._v(" "),t("li",[v._v("AOF（Append Only File）记录每次执行的命令，将新执行的命令保持到持久化文件末尾")]),v._v(" "),t("li",[v._v("也可以同时开启RDB+AOF两种方式，进一步可以进行一定配置解决AOF无限增长的问题。")])]),v._v(" "),t("h3",{attrs:{id:"rdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[v._v("#")]),v._v(" RDB")]),v._v(" "),t("p",[v._v("优点")]),v._v(" "),t("ol",[t("li",[v._v("快照功能：RDB的备份文件十分的紧凑，可以根据RDB恢复到不同时间节点的Redis快照版本")]),v._v(" "),t("li",[v._v("便于容灾：RDB的备份文件十分适合容灾恢复，可以传入远程的数据中心进行备份")]),v._v(" "),t("li",[v._v("利用Linux机制：RDB在执行持久化工作时会fork（in Linux）一个子进程进行持久化操作，写时复制(Copy-On-Write)让子进程不会立即拷贝全量数据，")]),v._v(" "),t("li",[v._v("消耗小、效率高：相比于AOF，RDB备份的文件小、恢复快")])]),v._v(" "),t("p",[v._v("缺点")]),v._v(" "),t("ol",[t("li",[v._v("丢数据较多：RDB对数据持久化不是很及时，容易丢失一段时间的数据")]),v._v(" "),t("li",[v._v("数据大时消耗大：虽然有COW技术，但是如果Redis实例中的数据较多时（10G以上），RDB时fork也会非常耗时，甚至会导致秒级别的阻塞。（但是这种情况不止RDB会耗时、其他的命令也会因为数据量过大而耗时，让Redis可用性下降，这种情况一般会考虑用Redis集群去存储数据）")])]),v._v(" "),t("h3",{attrs:{id:"aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[v._v("#")]),v._v(" AOF")]),v._v(" "),t("p",[v._v("优点")]),v._v(" "),t("ol",[t("li",[v._v("丢数据较少：AOF又分为多种触发时机，相较于RDB合理配置能够让Redis宕机时丢失的数据较少。")]),v._v(" "),t("li",[v._v("重写AOF缩小体积：开启子线程对AOF中日志文件进行重写，去除一些失效的日志文件，缩小AOF数据的体积。")]),v._v(" "),t("li",[v._v("fork消耗小：AOF也是通过fork子进程进行持久化操作的，不过每次AOF设计的操作较小，所以不会有Redis数据多fork消耗大的问题。")])]),v._v(" "),t("p",[v._v("缺点")]),v._v(" "),t("ol",[t("li",[v._v("体积大、效率低：相比于RDB，AOF日志文件的体积较大，并且恢复较慢")])]),v._v(" "),t("h3",{attrs:{id:"rdb-aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb-aof"}},[v._v("#")]),v._v(" RDB+AOF")]),v._v(" "),t("p",[v._v("4.X之后的版本进行AOF重写时，通过RDB方式直接舍弃快照前的历史数据，性能更优秀")]),v._v(" "),t("h2",{attrs:{id:"redis过期淘汰"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis过期淘汰"}},[v._v("#")]),v._v(" Redis过期淘汰")]),v._v(" "),t("ol",[t("li",[v._v("**精度：**精度可以打到0~1毫秒")]),v._v(" "),t("li",[v._v("**绝对时间点：**Redis通过Unix时间戳进行过期时间存储，这意味着多实例Redis时钟不同步会出现数据不一致问题")]),v._v(" "),t("li",[v._v("**清除策略：**Redis过期淘汰通过主动和被动两种方式，被动就是客户端访问到过期数据时进行过期删除，主动是指每10s执行的定时任务进行过期键清除")]),v._v(" "),t("li",[v._v("**Slave处理过期键：**Slave不会主动处理过期键，而是会通过Master删除过期键后再向Slave同步。当Slave成功当选为Master后会再执行过期键删除策略。")])]),v._v(" "),t("h2",{attrs:{id:"redis内存淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis内存淘汰策略"}},[v._v("#")]),v._v(" Redis内存淘汰策略")]),v._v(" "),t("p",[v._v("Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。")]),v._v(" "),t("p",[v._v("可以根据数据和策略两个维度进行考虑，分为下列这张表格这几种类型。")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th"),v._v(" "),t("th",[v._v("LRU")]),v._v(" "),t("th",[v._v("LFU")]),v._v(" "),t("th",[v._v("Random")]),v._v(" "),t("th",[v._v("TTL")]),v._v(" "),t("th",[v._v("None")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("allkeys")]),v._v(" "),t("td",[t("strong",[v._v("allkeys-lru")])]),v._v(" "),t("td",[t("strong",[v._v("allkeys-lfu")])]),v._v(" "),t("td",[t("strong",[v._v("allkeys-random")])]),v._v(" "),t("td"),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td",[v._v("volatile(含过期时间)")]),v._v(" "),t("td",[t("strong",[v._v("volatile-lru")])]),v._v(" "),t("td",[t("strong",[v._v("volatile-lfu")])]),v._v(" "),t("td",[t("strong",[v._v("volatile-random")])]),v._v(" "),t("td",[t("strong",[v._v("volatile-ttl")])]),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td",[v._v("None")]),v._v(" "),t("td"),v._v(" "),t("td"),v._v(" "),t("td"),v._v(" "),t("td"),v._v(" "),t("td",[t("strong",[v._v("no-eviction")])])])])]),v._v(" "),t("h2",{attrs:{id:"redis的集群模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis的集群模式"}},[v._v("#")]),v._v(" Redis的集群模式")]),v._v(" "),t("h3",{attrs:{id:"主从"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从"}},[v._v("#")]),v._v(" 主从")]),v._v(" "),t("ul",[t("li",[v._v("解决：\n"),t("ul",[t("li",[v._v("单实例宕机")]),v._v(" "),t("li",[v._v("QPS扩展")])])]),v._v(" "),t("li",[v._v("问题：\n"),t("ul",[t("li",[v._v("需要自行配置主从切换触发监控")]),v._v(" "),t("li",[v._v("主从内存配置需要一致（木桶短板效应）")]),v._v(" "),t("li",[v._v("难以在线扩容")]),v._v(" "),t("li",[v._v("写入性能受单机限制")]),v._v(" "),t("li",[v._v("主从切换导致数据不一致（所以基于Redis的分布式锁不可靠）")])])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://image-static.segmentfault.com/124/529/1245298177-5e6ed603a6d8b_articlex",alt:"redis-master-slave"}})]),v._v(" "),t("h3",{attrs:{id:"哨兵-主从"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵-主从"}},[v._v("#")]),v._v(" 哨兵（+主从）")]),v._v(" "),t("ul",[t("li",[v._v("解决：\n"),t("ul",[t("li",[v._v("需要自行配置主从切换触发监控")])])]),v._v(" "),t("li",[v._v("问题：需要自行配置主从切换触发监控\n"),t("ul",[t("li",[v._v("主从内存配置需要一致（木桶短板效应）")]),v._v(" "),t("li",[v._v("难以在线扩容")]),v._v(" "),t("li",[v._v("写入性能受单机限制")]),v._v(" "),t("li",[v._v("主从切换导致数据不一致（所以基于Redis的分布式锁不可靠）")])])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://image-static.segmentfault.com/423/790/4237905659-5e6ed60450b11_articlex",alt:"redis-sentinel"}})]),v._v(" "),t("h3",{attrs:{id:"cluster-主从"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cluster-主从"}},[v._v("#")]),v._v(" Cluster（+主从）")]),v._v(" "),t("p",[v._v("这种方式将每次命令按照Redis Key进行分slot操作，映射到不同的Redis实例中，可以让Redis的写入性能得到较大提升，并且支持了横向扩展的能力。至于在哪里和怎样分slot，这就没有统一的答案，一般都有以下三种方式：")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("在Redis中使用slot算法：Redis官方提供，操作最简单，但是可定制化低。")])]),v._v(" "),t("li",[t("p",[v._v("在客户端处使用分slot算法：低成本客制化，客户端消耗较高，改动成本较大。")])]),v._v(" "),t("li",[t("p",[v._v("在Proxy使用分slot算法：大厂通用，但是带来另一个proxy的高QPS处理问题。")])]),v._v(" "),t("li",[t("p",[v._v("解决：")]),v._v(" "),t("ul",[t("li",[v._v("主从内存配置需要一致（木桶短板效应）")]),v._v(" "),t("li",[v._v("难以在线扩容")]),v._v(" "),t("li",[v._v("写入性能受单机限制")])])]),v._v(" "),t("li",[t("p",[v._v("问题：需要自行配置主从切换触发监控")]),v._v(" "),t("ul",[t("li",[v._v("主从切换导致数据不一致（所以基于Redis的分布式锁不可靠）")])])])]),v._v(" "),t("p",[t("img",{attrs:{src:"https://www.freesion.com/images/227/235edde9407d2cdc4428321099dbdd3b.png",alt:"在这里插入图片描述"}})])])}),[],!1,null,null,null);_.default=a.exports}}]);