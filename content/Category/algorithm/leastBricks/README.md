---
title: 砖墙
# shell 根据创建时间自动生成
date: 2021-05-02 09:41:52
tags:
- 哈希表
- LeetCode
categories:
- 算法题解
# author: Guanyuqian
# sidebar: true
# 是否发布
# publish: true
# 文档加密，md5加密的32位密文
# keys:
# 	- 'e10adc3949ba59abbe56e057f20f883e'
---

::: warning

你需要找出怎样画才能使这条线 **穿过的砖块数量最少** ，并且返回 **穿过的砖块数量** 。

:::

<!-- more -->

## 题目描述

你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。

你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。

给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。

> [554. 砖墙](https://leetcode-cn.com/problems/brick-wall/)



## 示例

```
输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
输出：2
       ↓
-|- -|- -|-
- - -|-|- - 
-|- - -|- -
- -|- - - -
- - -|-|- -
-|- - -|-|-

输入：wall = [[1],[1],[1]]
输出：3
```



## 提示

- `1 <= nums.length <= 1000`
- `1 <= nums[i] <= 2 * 109`
- `nums` 中的所有整数 **互不相同**

## 解法

- 时间复杂度：$\mathcal{O}(nm)$
- 空间复杂度：$\mathcal{O}(nm)$

由于砖墙是一面矩形，所以对于任意一条垂线，其穿过的砖块数量加上从边缘经过的砖块数量之和是一个定值，即砖墙的高度。

因此，问题可以转换成求「垂线穿过的砖块边缘数量的最大值」，用砖墙的高度减去该最大值即为答案。

实现代码如下：

```go
func leastBricks(wall [][]int) (res int) {
    hash := map[int]int{}
    for _, rows := range wall {
        length := 0
        for i := 0; i < len(rows) - 1; i++ {
            length += rows[i]
            if hash[length]++; hash[length] > res {
                res = hash[length]
            }
        }
    }
    return len(wall) - res
}
```
