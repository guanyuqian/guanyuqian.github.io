---
title: 各种锁的解释
# shell 根据创建时间自动生成
date: 2021-06-25 18:52:04
tags:
- 锁
categories:
- 学习笔记
# author: Guanyuqian
# sidebar: true
# 是否发布
# 文档加密，md5加密的32位密文
# copyright: false # disable the plugin in this page 
# copyright:
#  minLength: 40 # It will override global configuration. 
---

::: warning

乐观锁、悲观锁、自旋锁、互斥锁、独占锁、共享锁、读锁、写锁、统一锁、分段锁、公平锁、非公平锁、可重入锁、不可重入锁

:::

锁的类型有很多种，在不同的应用场景中同一个名字的锁代表的含义可能完全不同，但是本质上那么多名称的锁只是从不同的角度对锁的特性进行区分和描述罢了，只要能够理解这些名词代表的底层设计思想，就可以快速理解这些五花八门的锁。

## 乐观锁VS悲观锁
**上锁思想**分为乐观锁、悲观锁，在数据库中应用比较明显。

- 悲观锁：所以每次在操作数据的时候都会上锁
- 乐观锁：每次操作完后再去判断是否生效，一般使用CAS原理实现

乐观锁在读比例较大的场景的时候拥有更高的性能，因为悲观锁获取锁需要消耗额外的资源。
```sql
--- 悲观锁， for update。
select * from t_goods where id<>2 for update;

--- 乐观锁，利用额外的version字段。
update t_goods set status=2,version=version+1 where id=#{id} and version=#{version};
```

## 互斥锁VS自旋锁
**获取锁失败的行为**不同，分为互斥锁和自旋锁。此处的互斥锁和自旋锁一般特指操作系统中的锁类型。
权衡两者的性能重点在于互斥锁的「上下文切换」代价和自旋锁忙等占用「计算资源」代价大小。

- 互斥锁：线程获取锁失败后就阻塞，直到锁被释放后才被唤醒，其中有多次上下文切换的消耗。
- 自旋锁：线程获取锁失败后会尝试再次获取，直到获取到锁为止。（在底层CPU提供CAS函数保证获取自旋锁尝试获取的原子性）


## 独占锁（独占锁、排他锁）VS共享锁
**可否同时被不同对象拥有**，分为独占锁和共享锁的两个概念，这里又可以称独占锁为互斥锁、排他锁。
- 独占锁：独占锁在同一时间点只会被同一对象拥有
- 共享锁：共享锁在同一时间内可以被多个对象拥有

## 读锁VS写锁
**获取锁之后的行为**不同，可以将锁分为读锁和写锁。
- 读锁：获取锁后进行数据读取，不涉及数据改变，因此读锁算是共享锁
- 写锁：获取写锁进行数据更新，设计数据改变，因此写锁算是排他锁

## 统一锁VS分段锁
**加锁的范围**不同，可以分为统一锁和分段锁。
- 统一锁：在一次系统操作中对整个区域的数据上锁。
- 分段锁：在一次系统操作中对某部分区域的数据上锁。

分段锁会明显提升并发的性能，这种设计思想在Java的ConcurrentHashMap中有体现，同样在MySQL的表锁和行锁设计也属于也是这类思想。

## 公平锁VS非公平锁
**分配策略**不同可分为公平锁和非公平锁。
- 公平锁：公平锁是指多个线程按照申请锁的顺序来获取锁
- 非公平锁：非公平锁是指多个线程的优先级顺序来获取锁

## 可重入锁VS不可重入锁
是否具有**重复获取**这样特征又分为可重入锁和不可重入锁。
实际上可重入锁只是提供一种独特的编程方式，没有必须使用可重入锁才能够完成的逻辑。

## Golang的锁
对于编程语言的锁实现来说
- Java的锁机制比较复杂，一共提供了数十种不同类型的锁。
- Golang提供的锁机制比较简单，从并发编程的角度触发，分为两种：`sync.Mutex`（独占锁、互斥锁）、`sync.RWMutex`（共享锁、读写锁）。

值得一提的是，而`sync.Mutex`的实现又比较复杂，如果根据我们上述提到的锁特性去描述`sync.Mutex`的话，就是：`sync.Mutex`从上锁思想属于「悲观锁」，获取锁失败后「互斥锁」和「自旋锁」的行为，结合了「公平锁」和「非公平锁」的分配策略的「不可重入」的「独占锁」。

Golang的`sync.RWMutex`底层是借助Mutex实现的，所以它具备上述`sync.Mutex`的特性，但是更贴切属于「读写锁」也就是「共享锁」。