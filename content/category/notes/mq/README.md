---
title: 消息队列浅析
# shell 根据创建时间自动生成
date: 2021-08-24 10:42:49
tags:
- MQ
- 中间件
categories:
- 学习笔记
# author: Guanyuqian
# sidebar: true
# 是否发布
# publish: true
# 文档加密，md5加密的32位密文
# keys:
# 	- 'e10adc3949ba59abbe56e057f20f883e'
# copyright: false # disable the plugin in this page 
# copyright:
#  minLength: 40 # It will override global configuration. 
---

::: warning

在此处对MQ的概念进行介绍，以及对比主流几款MQ。

:::

<!-- more -->

## 为什么使用MQ

- **解耦**：将各个模块进行解耦，提高对整体系统的维护效率。
- **异步**：对于实时性要求不高的业务，使用消息队列实现异步，可以提升核心功能的相应时间，提供核心流程成功率。
- **削峰**：也就是限流，防止在极端场景下的高并发把服务器打卦。

MQ 可以应用但不局限于以下业务场景：

- 一对多，多对多异步解耦，基于发布订阅模型，对分布式应用进行异步解耦，增加应用的水平扩展能力。
- 削峰填谷，大促等流量洪流突然来袭时，MQ 可以缓冲突发流量，避免下游订阅系统因突发流量崩溃。
- 日志监控，作为重要日志的监控通信管道，将应用日志监控对系统性能影响降到最低。
- 消息推送，为社交应用和物联网应用提供点对点推送，一对多广播式推送的能力。
- 金融报文，发送金融报文，实现金融准实时的报文传输，可靠安全。
- 电信信令，将电信信令封装成消息，传递到各个控制终端，实现准实时控制和信息传递。

## MQ概念

衡量MQ，可以从多种特性维度去衡量，不同的产品在各种特性上有自己的选择，没有绝对好的实现，要结合使用场景来考虑适合使用那种类型的MQ。

### 性能

- 单实现（集群or机器）吞吐量几万
- 十几万
- 几十万
- 上百万

### 顺序保证

- 无序：为了保证传输性能，无序消息不保证所有消息的传输先后顺序。
- partition有序：保证一部分消息的先后顺序。
- 整体有序：保证全局消息的先后顺序。

### 交付保证（消息重复）

这里也仅仅只是一般级别的交付保证，不能保证在极端情况下这些系统还支持，这需要形式化验证来证明。

- At most once：订阅者最多收到1条同样的消息，可能存在消息丢失情况，开销最小。
- At least once：订阅者最少收到1条同样的消息，可能存在消息重复情况，开销一般。
- Exactly once：订阅者正好收到1条同样的消息，理想情况，开销最大。

### 消费模式

- 推模型：生产者需要把消息进行推送，当生产大于消费的时候，可能会出现消费者被打挂的情况。

- 拉模型：消费者在消费消息的时候再拉取，当消费大于生产的时候，可能会出现空转情况。

### 消息轨迹路由查询

是否支持MQ消息发送过程中的全链路查询，如果消息发送失败知道在那个环境出现了问题。

### 容灾

容灾备份一定程度上和MQ的存储实现与集群支持有关，支持磁盘存储+集群备份就更自然的实现对灾备的支持。此外就是是否独立设计了系统进行异常情况的自动运维功能。

- 容灾备份
- 人工立即介入恢复
- 一定程度上自动恢复（检测、替换、重启）

### 延迟消息

能否支持延迟发送或者延迟消费的消息模式

### 持久化

持久化位置可以分为

- 只存在生产端
- 只存在消费端
- 同时存在生产端和消费端
- 部分存在生产端和消费端

持久化形式可以分为：

- 磁盘
- 内存
- 数据库

### 事务（最终一致性）

解决数据库的事务和MQ消息的数据一致性，即数据库系统添加失败后支不支持MQ级别的事务同步回滚

### 消息回溯

在某个时间点之后一系列消息被消费完了，能否支持重新回到这个时间点重新消费已经消费过的消息。这一定程度上取决于MQ的存储方式实现，如果只在内存中存储，就不可能支持长时间的消息回溯，如果结合了磁盘存储就有可能实现长时间的消息回溯。

- 不支持
- 在一个partition内实现
- 全局实现

### 集群支持

- 单机
- 集群一主多从
- 集群多主多从

### 死信处理

对没有被正常消费的消息，会怎样处理

- 直接丢弃
- 重试多次
- 放入死信队列，等待后续定义处理

## MQ对比

|            | ActiveMQ                                                     | RabbitMQ                                                     | RocketMq                                                     | Kafka                                                        |
| ---------- | ------------------------------------------------------------ | :----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 持久化     | 内存、磁盘、数据库。支持少量堆积。                           | 内存、磁盘。支持少量堆积                                     | 磁盘。支持大量堆积。                                         | 内存、磁盘、数据库。支持大量堆积                             |
| 事务       | 支持                                                         | 特殊支持，性能损失严重                                       | 支持                                                         | 支持                                                         |
| 单机吞吐量 | 几万                                                         | 几万                                                         | 十万                                                         | 几十万                                                       |
| 消费模式   | push/pull                                                    | push/ pull                                                   |                                                              | pull                                                         |
| 集群支持   | 一主多从                                                     | 一主多从                                                     | 多主多从                                                     | 多主（分布式）                                               |
| 消息顺序   | 无序                                                         | 无序                                                         | 无序、partition有序、全局有序                                | partition有序                                                |
| 消息回溯   | 不支持                                                       | 不支持                                                       | 支持指定时间点的回溯                                         | 支持指定分区offset位置的回溯                                 |
| 负载均衡   | 支持友好                                                     | 支持不好                                                     | 支持友好                                                     | 支持友好                                                     |
| 交付保证   | at least once                                                | at least once、at most once                                  | at least once                                                | at least once、at most once                                  |
| 死信处理   | 不支持，可以自己实现                                         | 不支持，可以自己实现                                         | 定时重发、死信队列                                           | 不支持，可以自己实现                                         |
| 评价       | 成熟的产品，在很多公司得到应用，各种协议支持的都很好。       | 结合erlang语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护。不过，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug。 | 天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。 | 号称大数据的杀手锏，谈到大数据领域内的消息传输，Kafka主要特点是基于Pull的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。 |
| 应用场景   | 官方社区现在对ActiveMQ 5.x维护越来越少，较少在大规模吞吐的场景中使用。 | 如果你的数据量没有那么大，小公司优先选择功能比较完备的RabbitMQ。 | RoketMQ在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ。 | 大型公司建议可以选用，如果有日志采集功能，肯定是首选kafka了。 |